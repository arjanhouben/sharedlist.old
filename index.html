<html>
	<head>
		<title></title>
		<meta name="viewport" content="width=device-width,height=device-height,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
		<link rel="apple-touch-icon" href="icon-2.0.png">
		<style>
		html, body
		{
			background-color: #789;
			overflow: hidden;
			height: 100%;
			width: 100%;
			margin: 5px;
			position: absolute;
			box-sizing: border-box;
		}
		html, body > *
		{
			position: absolute;
		}
		#items
		{
			top: 28pt;
			bottom: 0;
			left: 0;
			right: 0;
		}
		.customfont
		{
			font-size: 18pt;
			font-family: sans-serif;
			font-weight: lighter;
		}
		input[type=text]
		{
			background-color: transparent;
			border-color: black;
			border-width: 0 0 1px 0;
			border-radius: 0;
			top: 0;
			left: 0;
			right: 0;
			height: 24pt;
		}
		#strike > div > span
		{
			text-decoration: line-through;
			color: #555;
			overflow: hidden;
		}
		.noselect
		{
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		#scrollbox
		{
			height: 100%;
			overflow: auto;
			-webkit-overflow-scrolling: touch;
		}
		.item
		{
			position: relative;
			width: 100%;
			overflow: hidden;
			white-space: nowrap;
			transition: width 1s ease-in-out, background-color 0.2s;
		}
		.item > span
		{
			display: inline-block;
		}
		.unsaved
		{
			font-style: italic;
		}
		.remove_all
		{
			width: 0;
			background-color: rgba( 0, 0, 0, 0.1 );
		}
		</style>
		<script type="text/javascript">
		"use strict";
		function for_key_value( obj, f )
		{
			for ( let k in obj )
			{
				if ( obj.hasOwnProperty( k ) )
				{
					f( k, obj[ k ] );
				}
			}
		}
		function getLastModified( items )
		{
			let m = 0;
			for_key_value(
				items,
				( k, v ) =>
				{
					if ( v && v.modified > m )
					{
						m = v.modified;
					}
				}
			);
			return m;
		}
		function LocalData()
		{
			this.get = function()
			{
				if ( !localStorage[ window.location.host + window.location.pathname ] )
				{
					localStorage[ window.location.host + window.location.pathname ] = "{}";
				}
				return JSON.parse( localStorage[ window.location.host + window.location.pathname ] );
			}
			
			this.set = function( data )
			{
				localStorage[ window.location.host + window.location.pathname ] = JSON.stringify( data );
			}
		}
		function bind( f, t )
		{
			let args = Array.prototype.slice.call( arguments, 2 );
			return function(){
				f.apply( t, args );
			}
		}
		function parseQuery( query )
		{
			let result = {};
			query
				.split( /\?|&/g )
				.filter( i => i )
				.forEach( i => {
					let key_value = i.split( '=' );
					result[ key_value[ 0 ] ] = key_value[ 1 ];
				}
			);
			return result;
		}
		function ALL( args, obj )
		{
			if ( !obj ) obj = document;
			return Array.prototype.slice.call( obj.querySelectorAll.call( obj, args ) );
		}
		function ONE( args, obj )
		{
			if ( !obj ) obj = document;
			return obj.querySelector.apply( obj, [ args ] );
		}
		function emptyrow()
		{
			let div = document.createElement( "div" );
			div.classList.add( "item" );
			let span = document.createElement( "span" );
			div.appendChild( span );
			div.span = span;
			return div;
		}
		function on( obj, ev, selector, f )
		{
			let old = obj[ ev ] || function() {};
			obj[ ev ] = function( e )
			{
				old( e );
				if ( selector )
				{
					let t = e.target;
					while ( t && t !== document )
					{
						if ( t.matches( selector ) )
						{
							return f.call( t, e, t );
						}
						t = t.parentNode;
					}
				}
				else
				{
					return f.call( e.target, e, e.target );
				}
			}
		}
		function Timer( duration, callbacks )
		{
			if ( !callbacks ) callbacks = {};
			let args = Array.prototype.slice.call( arguments, 2 );
			let to = 0;
			let always = callbacks.always;
			let end = function( f )
			{
				if ( to )
				{
					clearTimeout( to );
					to = 0;
					if ( always )
					{
						always.apply( this, args );
						always = 0;
					}
					if ( f ) f.apply( this, args );
				}
			}
			if ( duration )
			{
				to = setTimeout( end.bind( this, callbacks.timeout ), duration );
			}
			this.cancel = end.bind( this, callbacks.cancel );
			this.abort = end.bind( this, callbacks.abort );
			return this;
		}
		window.onload = function()
		{
			document.title = location.pathname.split( '/' ).filter( i => i ).pop();
			let query = parseQuery( location.search );
			let currentData = new LocalData();
			let container = ONE( "#scrollbox" );
			let item_cache = {};
			let hidden_items = document.createDocumentFragment();
			let option_fragment = document.createDocumentFragment();
			
			if ( query.hasOwnProperty( "reset" ) )
			{
				currentData.set( {} );
			}
			
			if ( query.hasOwnProperty( "bg" ) )
			{
				ALL("html,body").forEach( o => o.style.backgroundColor = query[ "bg" ] );
			}
			
			function getRow( item )
			{
				while ( !item.classList.contains( "item" ) )
				{
					item = item.parentNode;
				}
				return item;
			}
			
			function insertInActive( elem, context )
			{
				elem.classList.remove( "hidden", "strike" );
				const active = ONE("#active", context);
				let str = elem.firstChild.innerText;
				let items = active.children;
				for ( let e of items )
				{
					if ( e.firstChild.innerText > str )
					{
						e.parentNode.insertBefore( elem, e );
						return;
					}
				}
				active.appendChild( elem );
			}
			
			function create_row( str, context )
			{
				let row = emptyrow();
				row.span.innerText = str;
				insertInActive( row, context );
				item_cache[ str ] = row;
				return row;
			}
			
			function get_or_create_item( str, context )
			{
				return item_cache[ str ] || create_row( str, context );
			}
			
			function updatePageJson( data )
			{
				return updatePage( JSON.parse( data ) );
			}
			
			function isEmpty( obj )
			{
				return Object.keys( obj ).length === 0;
			}
			
			function is_name_used_for_sync( v )
			{
				switch( v )
				{
					case "hidden":
					case "active":
					case "strike":
					case "discard":
						return true;
					default:
						return false;
				}
			}
			
			function fillPage( data )
			{
				let fragment = document.createDocumentFragment();
				let scroll_position = ONE("#scrollbox").scrollTop;
				fragment.appendChild( ONE("#items") );
				
				for ( let name in data )
				{
					let state = data[ name ].state;
					let item = get_or_create_item( name, fragment );
					item.classList.remove( "hidden", "strike" );
					state
						.split( ' ' )
						.filter( is_name_used_for_sync )
						.forEach( v => item.classList.add( v ) );
				}
				ALL(".hidden",fragment).forEach( i => hidden_items.appendChild( i ) );
				let strike = ONE("#strike",fragment);
				ALL(".strike",fragment).forEach( i => strike.appendChild( i ) );
				ONE("body").appendChild(fragment);
				ONE("#scrollbox").scrollTop = scroll_position;
				ONE("#input-field").appendChild( option_fragment );
			}
			
			function sort_by_usecount( collection, func )
			{
				let result = [];
				for_key_value( collection, ( k,v ) => result.push( { "name": k, ...v } ) );
				result.forEach( i => i.usecount = i.usecount || 0 );
				result.sort( (a,b) => a.usecount - b.usecount );
				return result;
			}
			
			function get_or_create_option( name )
			{
				let opt = ONE("option[value=\"" + name + "\"]") || ONE("option[value=\"" + name + "\"]",option_fragment);
				if ( !opt )
				{
					opt = document.createElement( "option" );
					opt.value = name;
				}
				return opt;
			}

			function updateOptionOrder( items_in_order )
			{
				let datalist = ONE("#input-field");
				datalist.appendChild( option_fragment );
				option_fragment.appendChild( datalist );
				items_in_order.forEach(
					(k,v) => {
						datalist.appendChild( get_or_create_option( k.name ) )
						}
				)
				ONE("body").appendChild( datalist );
			}
			
			function updatePage( data )
			{
				let complete = currentData.get();
				let diff = get_new_changes( complete, data[ "items" ] );
				for_key_value(
					data[ "items" ],
					( k, v ) => complete[ k ] = v
				);

				currentData.set( complete );
				
				updateOptionOrder( sort_by_usecount( complete ).reverse()  );
				
				if ( !isEmpty( data.errors ) )
				{
					console.log( data.errors );
				}
				fillPage( diff );
				
				ALL(".unsaved").forEach( o => o.classList.remove( "unsaved" ) );
			}
			
			function filter( collection, filter_function )
			{
				return Array.prototype.filter.call(
					collection,
					filter_function
				);
			}
			
			function getItemsFromPage()
			{
				let cache = currentData.get();
				let items = {};
				for_key_value(
					item_cache,
					function( k, v )
					{
						let m = 0;
						if( cache.hasOwnProperty( k ) && cache[ k ] )
						{
							if ( cache[ k ].hasOwnProperty( "modified" ) )
							{
								m = cache[ k ].modified;
							}
						}
						items[ k ] = {
							"modified": m,
							"state": filter( v.classList, is_name_used_for_sync ).join( " " )
						}
					}
				)
				return items;
			}
			
			function itemDifferent( a, b )
			{
				return !a || !b || ( a[ "state" ] !== b[ "state" ] );
			}
		
			function get_new_changes( old_value, new_value )
			{
				let result = {};
				if ( !old_value )
				{
					return new_value;
				}
				for_key_value(
					new_value,
					function( k, v )
					{
						if ( v )
						{
							if ( old_value.hasOwnProperty( k ) )
							{
								if ( itemDifferent( old_value[ k ], v ) )
								{
									result[ k ] = v;
								}
							}
							else
							{
								result[ k ] = v;
							}
						}
					}
				)
				return result;
			}
			
			function post( url, data, complete )
			{
				let xhr = new XMLHttpRequest();
				xhr.onreadystatechange = function()
				{
					if ( xhr.readyState == XMLHttpRequest.DONE )
					{
						complete( xhr.responseText );
					}
				}
				let xhrdata = "json=" + encodeURIComponent( JSON.stringify( data ) );
				xhr.open( "POST", url );
				xhr.setRequestHeader( "Content-type", "application/x-www-form-urlencoded" );
				xhr.send( xhrdata );
			}

			function sync()
			{
				if ( navigator.onLine )
				{
					let lastServerData = currentData.get();
					
					let items_from_page = getItemsFromPage();
					let diff = get_new_changes(
						lastServerData,
						items_from_page
					);
					
					if ( !isEmpty( diff ) )
					{
						diff = { "items" : diff };
					}
					
					let lastModified = getLastModified( lastServerData );
					if ( lastModified )
					{
						diff[ "lastModified" ] = lastModified;
					}
					
					post(
						"sync.php",
						diff,
						updatePageJson
					);
				}
			}
			
			function addRow( str )
			{
				if ( str.length )
				{
					let row = get_or_create_item( str );
					insertInActive( row );
				}
			}
			
			let input = ONE("input[name=item]");
			
			let sync_timeout = null;
			
			function syncIfNeeded()
			{
				// wait a bit in case the press that caused this update also
				// triggered a real sync
				clearTimeout( sync_timeout );
				sync_timeout = setTimeout( sync, 1000 );
			}
			
			function push_front( where, what )
			{
				where.insertBefore( what, where.firstChild );
			}
			
			let start_touch = new Timer();
			
			function toggle_row( t )
			{
				let row = getRow( t );
				let parent_type = row.parentNode.id;
				if ( parent_type == "strike" )
				{
					insertInActive( row );
				}
				else
				{
					row.classList.add( "strike" );
					push_front( ONE("#strike"), row );
				}
				row.classList.add( "unsaved" );
				syncIfNeeded();
			}
			
			function long_press( t )
			{
				let collection;
				
				if ( t.parentNode.id == "strike" )
				{
					collection = ALL("#strike>div");
				}
				else
				{
					collection = [ t ];
				}
				
				collection.forEach( o => o.classList.add( "remove_all" ) );
				let obj = t;
				start_touch = new Timer(
					1000,
					{
						"timeout": function( o )
						{
							collection.forEach( o => {
									o.classList.add( "hidden", "discard" );
									hidden_items.appendChild( o );
								}
							)
							syncIfNeeded();
						},
						"always": () => collection.forEach( o => o.classList.remove( "remove_all" ) )
					},
					obj
				);
			}
			
			let start_press = 0;
			
			on( document,
				"onmousedown",
				".item",
				( e, obj ) =>
				{
					start_press = e.timeStamp;
					long_press( obj );
				}
			)
			
			on( document,
				"onmouseup",
				".item",
				( e ) => { start_touch.abort(); }
			)
			
			on( document,
				"onmousemove",
				".item",
				( e ) => { start_press = 0; }
			)
			
			on( document,
				"onclick",
				".item",
				function( e, obj )
				{
					input.blur();
					if ( e.timeStamp - start_press < 100 )
					{
						toggle_row( obj );
					}
				}
			)
			
			document.ontouchstart = document.onmousedown;
			document.ontouchend = document.onmouseup;
			
			document.onkeyup = function( e )
			{
				if ( e.keyCode == 13 )
				{
					addRow( input.value.trim() );
					input.value = "";
					syncIfNeeded();
				}
			}
			
			input.oninput = function()
			{
				this.value = this.value.toLowerCase();
			}
			
			document.onvisibilitychange = syncIfNeeded;
			
			fillPage( currentData.get() );
			sync();
		}
		</script>
	</head>
	<body class="customfont noselect">
		<input class="customfont" name="item" type="text" list="input-field" />
		<datalist id="input-field">
		</datalist>
		<div id="items">
			<div id="scrollbox">
				<div id="active"></div>
				<div id="strike"></div>
			</div>
		</div>
	</body>
</html>
